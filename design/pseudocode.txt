// this is written in some mangled mix of javascript and python
// (I guess that makes it kind of like coffeescript, in theory)
//
// note that anything added to an object's prototype is simply an instance
// method or variable. anything added to an object is a class method or var.


/* AST representation */

ASTNode = function(args):
  this.args = {}
  for arg, i in args:
    argName = this.argMap[i] || i // use the arg name corresponding to this index
    if !isASTArray(arg):
      this.args[argName] = arg
    else:
      nodeType = arg.pop()
      this.args[argName] = ASTNode.Types[nodeType](arg)

ASTNode.prototype.eval(context, evaledArgs):
  for arg, argName in this.args:
    if !evaledArgs[argName]:
      nextFrame = {
        node: arg,
        context: context,
        resultName: argName
      }
      return {result: "frame", frame: nextFrame}

  returnValue = this.evaluate(context, evaledArgs);
  return {result: "return", returnValue: returnValue}

// map from ASTNode name to ASTNode class, one for each node type
ASTNode.Types = {}


/* Environment representation */

Variable = function():
  this.history = []

Variable.prototype = {
  push: function(value, evalIndex):
    if this.history.last.evalIndex > lastCheckpointIndex:
      this.history.pop()
    this.history.push({value: value, evalIndex: evalIndex})

  getValueAtIndex: function(evalIndex):
    isLive = function(snapshot):
      return snapshot.evalIndex <= evalIndex
    currentValue = findLast(this.history, isLive)
    return currentValue ? currentValue.value : undefined
}

Pointer = function(heap, heapId):
  this.heap = heap
  this.heapId = heapId

Pointer.prototype = {
  setValue: function(val):
    evalIndex = activeEvaluation.nextEvalIndex()
    return this.heap.set(this.heapId, val, evalIndex)

  getValue: function():
    return this.heap.get(this.heapId, currentEvalIndex)
}

Heap = function():
  this.vars = {}
  this.nextId = 0

Heap.prototype = {
  add: function(val, evalIndex):
    heapId = this.nextId++
    this.vars[heapId] = Variable()
    this.set(heapId, val, evalIndex)
    return Pointer(this, heapId)

  set: function(heapId, val, evalIndex):
    this.vars[heapId].push(val, evalIndex)

  get: function(heapId, evalIndex):
    return this.vars[heapId].getValueAtIndex(evalIndex)
}

Stack = function(parent, heap):
  this.parent = parent
  this.heap = heap
  this.vars = {}

Stack.prototype = {
  declare: function(name, val):
    if !this.vars[name]:
      this.vars[name] = Variable()
    if val != undefined:
      this.set(name, val)

  set: function(name, val):
    if !this.vars[name]:
      return this.parent.set(name, val)
    evalIndex = activeEvaluation.nextEvalIndex()
    if !isPrimitive(val):
      val = this.heap.add(val, evalIndex)
    this.vars[name].push(val, evalIndex)

  get: function(name):
    if this.vars[name]:
      value = this.vars[name].getValueAtIndex(currentEvalIndex)
      if value != undefined:
        return value
    else:
      return this.parent.get(name)
}


/* Evaluation */

Evaluation = function(programNode):
  this.heap = Heap()
  this.stack = Stack(undefined, this.heap)
  this.currentEvalIndex = 0
  this.evalStack = []
  this.evalStack.push({
    node: programNode,
    context: this.stack,
    resultName: "result",
    evaledArgs: {},
    result: undefined
  })
  this.result = undefined

Evaluation.prototype = {
  nextEvalIndex: function():
    return this.currentEvalIndex++

  evaluate: function(evalIndex):
    if evalIndex:
      this.setToCheckpoint(evalIndex)

    while (frame = evalStack.last):
      // if the current frame has produced a result, save it to the containing
      // frame and pop the stack
      if frame.result != undefined:
        evalStack.pop()
        if evalStack.last:
          evalStack.last.evaledArgs[frame.resultName] = frame.result
        else:
          this.result = frame.result
          return this.result

      // otherwise, make an evaluation step on the current frame. an evaluation
      // step can either produce a return value or a new frame to eval
      else:
        eval = frame.node.eval(frame.context, frame.evaledArgs)
        match eval.result:
          "return": frame.result = eval.returnValue
          "frame": evalStack.push({
                    node: eval.frame.node,
                    context: eval.frame.context,
                    resultName: eval.frame.resultName,
                    evaledArgs: {},
                    result: undefined
                  })

  setToCheckpoint: function(evalIndex):
    this.currentEvalIndex = evalIndex
    // and then, reconstruct the appropriate eval stack
}
